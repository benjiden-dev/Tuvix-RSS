name: 'Substitute D1 Database ID'
description: 'Substitutes D1_DATABASE_ID placeholder in wrangler.toml'

inputs:
  wrangler-toml-path:
    description: 'Path to wrangler.toml file'
    required: false
    default: 'packages/api/wrangler.toml'
  d1-database-id:
    description: 'D1 Database ID secret'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Substitute D1 database ID
      shell: bash
      env:
        D1_DATABASE_ID: ${{ inputs.d1-database-id }}
        WRANGLER_TOML_PATH: ${{ inputs.wrangler-toml-path }}
      run: |
        python3 -c "
        import re
        import sys
        import os
        import shutil
        import textwrap
        
        # Read script from stdin and dedent it
        script = sys.stdin.read()
        exec(textwrap.dedent(script))
        " << 'SCRIPT_END'
        # Get inputs from environment
        d1_database_id = os.environ.get('D1_DATABASE_ID')
        wrangler_toml_path = os.environ.get('WRANGLER_TOML_PATH')
        
        # Verify secret is set (without leaking value)
        if not d1_database_id:
            print('::error::D1_DATABASE_ID secret is not set')
            sys.exit(1)
        
        # Trim whitespace from database ID
        d1_database_id = d1_database_id.strip()
        
        # Verify the trimmed value is not empty
        if not d1_database_id:
            print('::error::D1_DATABASE_ID is empty after trimming')
            sys.exit(1)
        
        # Convert to absolute path
        wrangler_toml_path = os.path.abspath(wrangler_toml_path)
        
        # Verify file exists
        if not os.path.isfile(wrangler_toml_path):
            print(f'::error::wrangler.toml file not found at: {wrangler_toml_path}')
            sys.exit(1)
        
        # Read the file
        try:
            with open(wrangler_toml_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f'::error::Failed to read wrangler.toml: {e}')
            sys.exit(1)
        
        # Verify placeholder exists in file
        placeholder = '${D1_DATABASE_ID}'
        if placeholder not in content:
            print(f'::error::Placeholder {placeholder} not found in wrangler.toml')
            sys.exit(1)
        
        # Perform substitution (replace envsubst functionality)
        substituted_content = content.replace(placeholder, d1_database_id)
        
        # Verify substitution succeeded (placeholder should be gone)
        if placeholder in substituted_content:
            print('::error::Substitution failed - placeholder still present')
            sys.exit(1)
        
        # Verify database_id is not empty after substitution
        if 'database_id = ""' in substituted_content:
            print('::error::database_id is empty after substitution')
            sys.exit(1)
        
        # Clean up the database_id line - ensures proper TOML formatting
        # This fixes any trailing whitespace or characters that might cause TOML parsing errors
        print('ðŸ”§ Cleaning database_id line with Python...')
        
        lines = substituted_content.splitlines(keepends=False)
        
        found = False
        for i, line in enumerate(lines):
            # Check if this is the database_id line (strip to handle whitespace)
            stripped = line.strip()
            if stripped.startswith('database_id = '):
                # Extract the value using regex - handle any whitespace around =
                match = re.search(r'database_id\s*=\s*"([^"]+)"', line)
                if match:
                    db_value = match.group(1).strip()
                    if not db_value:
                        print('::error::database_id value is empty')
                        sys.exit(1)
                    
                    # Get indentation from original line (before stripping)
                    indent_match = re.match(r'^(\s*)', line)
                    indent_str = indent_match.group(1) if indent_match else ''
                    
                    # Create clean line: exactly "database_id = "value"" with no trailing content
                    lines[i] = f'{indent_str}database_id = "{db_value}"'
                    print(f'âœ… Fixed line {i+1} (value length: {len(db_value)}, indent: {len(indent_str)})')
                    found = True
                    break
        
        if not found:
            print('::error::database_id line not found in file')
            sys.exit(1)
        
        # Join lines with newlines and ensure file ends with exactly one newline
        output = '\n'.join(lines)
        if output and not output.endswith('\n'):
            output += '\n'
        
        # Write to temporary file first
        temp_file = wrangler_toml_path + '.tmp'
        try:
            with open(temp_file, 'w', encoding='utf-8', newline='\n') as f:
                f.write(output)
        except Exception as e:
            print(f'::error::Failed to write temporary file: {e}')
            sys.exit(1)
        
        # Verify temp file exists
        if not os.path.isfile(temp_file):
            print('::error::Temporary file disappeared after writing')
            sys.exit(1)
        
        # Verify the line is properly formatted (no trailing content after quote)
        # Match: optional whitespace, database_id, optional whitespace, =, optional whitespace, ", value, ", optional whitespace, end of line
        database_id_pattern = re.compile(r'^\s*database_id\s*=\s*"[^"]*"\s*$')
        database_id_line_found = False
        
        with open(temp_file, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                if database_id_pattern.match(line.rstrip('\n\r')):
                    database_id_line_found = True
                    break
        
        if not database_id_line_found:
            print('::error::database_id line format verification failed')
            print('Actual line content (searching for database_id):')
            with open(temp_file, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    if 'database_id' in line:
                        # Show line with visible characters
                        visible_line = repr(line.rstrip('\n\r'))
                        print(f'  Line {line_num}: {visible_line}')
                        # Show hex dump
                        hex_dump = ' '.join(f'{ord(c):02x}' for c in line.rstrip('\n\r'))
                        print(f'  Hex: {hex_dump}')
            sys.exit(1)
        
        # Verify database_id value is not empty (double-check)
        db_value_pattern = re.compile(r'^\s*database_id\s*=\s*"([^"]*)"')
        db_value_check = None
        
        with open(temp_file, 'r', encoding='utf-8') as f:
            for line in f:
                match = db_value_pattern.match(line.rstrip('\n\r'))
                if match:
                    db_value_check = match.group(1)
                    break
        
        if not db_value_check:
            print('::error::database_id value is empty after cleanup')
            sys.exit(1)
        
        print('âœ… Line cleaned and verified successfully')
        
        # Final verification: ensure the line exists and has content
        final_pattern = re.compile(r'^\s*database_id\s*=\s*"[^"]+"')
        final_check_passed = False
        
        with open(temp_file, 'r', encoding='utf-8') as f:
            for line in f:
                if final_pattern.match(line.rstrip('\n\r')):
                    final_check_passed = True
                    break
        
        if not final_check_passed:
            print('::error::Final verification failed - database_id line missing or malformed')
            print('File content around database_id:')
            with open(temp_file, 'r', encoding='utf-8') as f:
                lines_list = f.readlines()
                for i, line in enumerate(lines_list):
                    if 'database_id' in line:
                        start = max(0, i - 3)
                        end = min(len(lines_list), i + 4)
                        for j in range(start, end):
                            marker = '>>> ' if j == i else '    '
                            print(f'{marker}{j+1}: {lines_list[j].rstrip()}')
                        break
                else:
                    print('No database_id line found')
            sys.exit(1)
        
        # Move substituted file into place (using shutil.move for cross-platform compatibility)
        try:
            shutil.move(temp_file, wrangler_toml_path)
        except Exception as e:
            print(f'::error::Failed to move file: {e}')
            sys.exit(1)
        
        print('âœ… File moved successfully')
        print('âœ… Successfully substituted D1_DATABASE_ID (value not logged for security)')
        SCRIPT_END
