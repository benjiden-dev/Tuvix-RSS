name: 'Substitute D1 Database ID'
description: 'Substitutes D1_DATABASE_ID placeholder in wrangler.toml'

inputs:
  wrangler-toml-path:
    description: 'Path to wrangler.toml file'
    required: false
    default: 'packages/api/wrangler.toml'
  d1-database-id:
    description: 'D1 Database ID secret'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Substitute D1 database ID
      shell: bash
      env:
        D1_DATABASE_ID: ${{ inputs.d1-database-id }}
      run: |
        # Store absolute path to wrangler.toml for consistency
        WRANGLER_TOML_PATH=$(cd "$(dirname "${{ inputs.wrangler-toml-path }}")" && pwd)/$(basename "${{ inputs.wrangler-toml-path }}")
        
        # Verify secret is set (without leaking value)
        if [ -z "$D1_DATABASE_ID" ]; then
          echo "::error::D1_DATABASE_ID secret is not set"
          exit 1
        fi
        
        # Trim any whitespace from the database ID value (prevents issues with secret formatting)
        # Use parameter expansion instead of xargs to avoid quote issues
        D1_DATABASE_ID="${D1_DATABASE_ID#"${D1_DATABASE_ID%%[![:space:]]*}"}"  # Remove leading whitespace
        D1_DATABASE_ID="${D1_DATABASE_ID%"${D1_DATABASE_ID##*[![:space:]]}"}"  # Remove trailing whitespace
        
        # Verify the trimmed value is not empty
        if [ -z "$D1_DATABASE_ID" ]; then
          echo "::error::D1_DATABASE_ID is empty after trimming"
          exit 1
        fi
        
        # Verify placeholder exists in file
        if ! grep -q '\${D1_DATABASE_ID}' "$WRANGLER_TOML_PATH"; then
          echo "::error::Placeholder \${D1_DATABASE_ID} not found in wrangler.toml"
          exit 1
        fi
        
        # Perform substitution with explicit variable list
        envsubst '$D1_DATABASE_ID' < "$WRANGLER_TOML_PATH" > "$WRANGLER_TOML_PATH".tmp
        
        # Verify substitution succeeded (placeholder should be gone)
        if grep -q '\${D1_DATABASE_ID}' "$WRANGLER_TOML_PATH".tmp; then
          echo "::error::Substitution failed - placeholder still present"
          exit 1
        fi
        
        # Verify database_id is not empty after substitution
        if grep -q 'database_id = ""' "$WRANGLER_TOML_PATH".tmp; then
          echo "::error::database_id is empty after substitution"
          exit 1
        fi
        
        # Clean up the database_id line to ensure it ends with just a newline (no trailing whitespace)
        # This fixes TOML parsing issues where trailing characters after the value cause errors
        # Extract the database ID value and reconstruct the line perfectly
        echo "ðŸ” Extracting database_id value..."
        DB_VALUE=$(grep '^database_id = ' "$WRANGLER_TOML_PATH".tmp | sed 's/^database_id = "\(.*\)".*/\1/')
        if [ -z "$DB_VALUE" ]; then
          echo "::error::Could not extract database_id value"
          echo "Debug: Checking database_id line from file..."
          RAW_LINE=$(grep '^database_id = ' "$WRANGLER_TOML_PATH".tmp || echo "NOT_FOUND")
          if [ "$RAW_LINE" != "NOT_FOUND" ]; then
            echo "Debug: Line found, length: ${#RAW_LINE}"
            echo "Debug: Line starts with: ${RAW_LINE:0:20}..." # Only show "database_id = " part
            echo "Debug: Contains quotes: $(echo "$RAW_LINE" | grep -q '"' && echo "yes" || echo "no")"
            echo "Debug: Value portion length: $(( ${#RAW_LINE} - 20 ))" # Length of value part only
          else
            echo "Debug: database_id line not found in file"
          fi
          exit 1
        fi
        # Verify extracted value is not empty
        if [ ${#DB_VALUE} -eq 0 ]; then
          echo "::error::Extracted database_id value is empty"
          echo "Debug: Extraction succeeded but value length is 0"
          exit 1
        fi
        echo "âœ… Extracted value successfully (length: ${#DB_VALUE}, format: ${DB_VALUE:0:8}...${DB_VALUE: -4})"
        
        # Reconstruct the line perfectly: database_id = "value" with newline
        # Use awk to replace the line with the perfectly formatted version
        echo "ðŸ”§ Reconstructing database_id line..."
        awk -v db_value="$DB_VALUE" '/^database_id = / { printf "database_id = \"%s\"\n", db_value; next } { print }' "$WRANGLER_TOML_PATH".tmp > "$WRANGLER_TOML_PATH".tmp2
        if [ ! -s "$WRANGLER_TOML_PATH".tmp2 ]; then
          echo "::error::Reconstruction failed - output file is empty"
          exit 1
        fi
        mv "$WRANGLER_TOML_PATH".tmp2 "$WRANGLER_TOML_PATH".tmp
        echo "âœ… Line reconstructed successfully"
        
        # Verify the database_id line exists and has content
        # Since we reconstructed it with awk, we know it's correctly formatted
        # Just verify it exists and the value is not empty
        echo "ðŸ” Validating reconstructed line..."
        DB_LINE=$(grep '^database_id = ' "$WRANGLER_TOML_PATH".tmp)
        if [ -z "$DB_LINE" ]; then
          echo "::error::database_id line not found after reconstruction"
          echo "Debug: Checking if file exists and has content..."
          ls -la "$WRANGLER_TOML_PATH".tmp || echo "File not found"
          wc -l "$WRANGLER_TOML_PATH".tmp || echo "Cannot count lines"
          exit 1
        fi
        echo "Debug: Line found, length: ${#DB_LINE}"
        echo "Debug: Line starts with: ${DB_LINE:0:20}..."
        
        # Verify the value we used for reconstruction is still in the line
        # This confirms the reconstruction worked correctly
        if ! echo "$DB_LINE" | grep -qF "\"$DB_VALUE\""; then
          echo "::error::database_id line does not contain expected value after reconstruction"
          echo "Debug: Expected value length: ${#DB_VALUE}"
          echo "Debug: Expected value preview: ${DB_VALUE:0:8}...${DB_VALUE: -4}"
          echo "Debug: Actual line preview: ${DB_LINE:0:60}..."
          echo "Debug: Line ends with: ...${DB_LINE: -20}"
          exit 1
        fi
        echo "âœ… Value verification passed"
        
        # Basic sanity check: line should contain database_id = "
        if ! echo "$DB_LINE" | grep -q 'database_id = "'; then
          echo "::error::database_id line format is invalid"
          echo "Debug: Line does not contain 'database_id = \"'"
          echo "Debug: Line content: ${DB_LINE:0:50}..."
          exit 1
        fi
        echo "âœ… Format check passed"
        
        # Ensure the file ends with a newline (TOML requirement)
        # Read the file, ensure last line ends with newline
        if [ -s "$WRANGLER_TOML_PATH".tmp ]; then
          # Check if file ends with newline, if not add one
          LAST_BYTE=$(tail -c 1 "$WRANGLER_TOML_PATH".tmp | od -An -tx1 | tr -d ' ')
          if [ "$LAST_BYTE" != "0a" ]; then
            echo "" >> "$WRANGLER_TOML_PATH".tmp
          fi
        fi
        
        # Final verification: Check the database_id line one more time after all processing
        DB_LINE_FINAL=$(grep '^database_id = ' "$WRANGLER_TOML_PATH".tmp)
        if [ -z "$DB_LINE_FINAL" ]; then
          echo "::error::database_id line missing in final file"
          exit 1
        fi
        
        # Verify it's a single line (no embedded newlines)
        LINE_COUNT=$(echo "$DB_LINE_FINAL" | wc -l)
        if [ "$LINE_COUNT" -ne 1 ]; then
          echo "::error::database_id line contains unexpected newlines"
          echo "Line: $DB_LINE_FINAL"
          exit 1
        fi
        
        # Move substituted file into place (using absolute path for consistency)
        # Note: TOML syntax will be validated by wrangler during deployment
        mv "$WRANGLER_TOML_PATH".tmp "$WRANGLER_TOML_PATH"
        
        echo "âœ… Successfully substituted D1_DATABASE_ID (value not logged for security)"

